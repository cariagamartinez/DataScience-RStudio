---
title: "Opciones para completar datos"
output: html_notebook
---
\

En el notebook 6 habíamos realizado una primera aproximación. Veamos ahora un poco más en profundidad acerca de cómo trabajar con datos faltantes. Para ello, vamos a cargar el dataset de trabajo y a guardarlo en una variable. Vamos a especificar que el dataset tiene cabecera y además, vamos a indicar que no identifique los strings como factores, ya que el dataset tiene valores NA que podrían interpretarse como valores discretos.

```{r}
housing.data <- read.csv("/Users/macbookariel/Library/Mobile Documents/com~apple~CloudDocs/@ARIEL/AADD/DataScience/DataScience-con-RStudio/@Ariel/b Datos/tema1/housing-with-missing-value.csv", header = TRUE, stringsAsFactors = FALSE)
```
\
Ante este dataframe, más o menos grande, el primer acercamiento es hacer un _resumen_ de toda la información contenida. Esto lo conseguimos con la función _**summary**_.

```{r}
summary(housing.data) -> summary_housing
View (summary_housing)
```
\

> Toda esta información se ve un poco mejor haciéndolo directamente en consola. Ejecutamos summary(housing.data).

\
La función _**summary**_ hará un resumen por columnas de toda la información, entregándonos el mínimo, la media, la mediana, el máximo y, de haberlos, el número de observaciones $NA$. En este caso, observamos que en las variables _rad_ y _ptratio_ hay al menos 40 observaciones como $NA$.

### Opciones para completar estos datos.
\

#### A) Podríamos omitir todos los datos $NA$, con la función _**na.omit**_

```{r}
housing.data1 <- na.omit(housing.data)
```
\
Veremos que así todos los $NAs$ desaparecen **PERO SE HABRÁN RECALCULADO LOS VALORES YA QUE SE ELIMINAN OBSERVACIONES Y HABRÁN VARIADO**.
\


#### B) Podríamos omitir todos los datos $NA$ unicamente de ciertas columnas (mientras nos quedamos con valores $NAs$ de otras columnas)

```{r}
drop_na <- c("rad")
housing.data.2 <- housing.data [
  complete.cases(housing.data[, !(names(housing.data))%in% drop_na]),
  ]
```
\

En este ejemplo, guardamos el nombre de la columna "rad" (que contiene $NAs$  **QUE QUEREMOS MANTENER**), en una nueva variable que llamamos _drop_na_.
\

Luego, generamos un nuevo dataframe (llamado _housing.data.2_) donde guardaremos todas las columnas del dataframe anterior (por eso tenemos la sintaxis _**housing.data[ blablabla **, **]**_).
\

Esa sintaxis _blablabla_ es la que nos permitirá escoger las filas (ya que está antes de la coma en los corchetes). En ella usamos la función _**complete.cases**_ (que devuelve un array de booleanos analizando si la fila esté completa).
\

¿Y qué va a analizar _**complete.cases**_? Pues accederá a todas las filas ([,)y a las columnas cuyo nombre NO ESTÉ GUARDADO EN LA VARIABLE _drop_na_ (!(names(housing.data))%in% drop_na]).
\


#### C) Podríamos eliminar toda la columna, asígnando el valor NULL

> housing.data$rad -> NULL #Eliminamos toda la columna "rad".


#### D) Podríamos eliminar ciertas columnas con $NA$ y quedarnos con aquellas que no contienen $NA$.

```{r}
drops <- c("rad", "ptratio")
housing.data.3 <- housing.data [, !(names(housing.data) %in% drops)]
```
\
En esta última sintaxis, nos quedamos con todas las filas del dataset _housing.data_ pero nos quedamos únicamente con aquellas columnas cuyo nombre no se encuentre entre los contenidos en la variable _drops_. En este caso, eliminaríamos 2 columnas.


























