---
title: "Reescalado"
output: html_notebook
---

### Reescalado de valores

\

A veces, los valores se mueven en un rango muy amplio, por lo que es posible que los valores más altos "tiren" de la computación, en detrimento de los más bajos. Por eso, se reescalan los valores para generar un nuevo rango (normalmente entre cero y uno, pero con los límites definidos por el operador). 
Este reescalado se realiza mediante el paquete _**scales**_.

```{r Cargamos scales}
library(scales)
```
\
Vamos a usar un CSV, guardándolo como siempre en una variable.

```{r}
students <- read.csv("/Users/macbookariel/Library/Mobile Documents/com~apple~CloudDocs/@ARIEL/AADD/DataScience/DataScience-con-RStudio/@Ariel/b Datos/tema1/data-conversion.csv")
```
\
En este CSV tenemos varios problemas, ya que hay distintas edades y diferentes cantidades de salarios.

Por ello, antes de analizar el fichero, vamos a reescalar la variable _Income_ entre cero y uno. 

Para ello, vamos a crear una nueva columna y vamos a aplicar la función _**rescale**_ del paquete _**scale**_:

```{r}
students$Income.rescaled <- rescale(students$Income)
```
\
La función anterior nos habrá creado una nueva columna y habrá reescalado entre cero y uno los valores originales. En esta función, el valor más bajo es igualado a cero y el valor más alto es igualado a uno: todos los valores intermedios sufren un reescalado LINEAL.
La fórmula consiste en:
\
**valor - mínimo valor / (máximo - mínimo)** (rango 0-1). 
\

En R sería:

```{r}
(students$Income - min(students$Income))/
  (max(students$Income)-min(students$Income)) -> formula
View(formula)
```
\
Con la función _**View**_ podemos ver el array generado, cuyos valores coinciden con la columna _Income.rescaled_
\

Otras veces, nos interesa cambiar el rango y para ello seguiremos usando la función _**rescale**_ pero haciendo uso del parámetro _**to**_, con el cual (con la sintaxis de vector $c$) podemos indicar el máximo y el mínimo. Por ejemplo, imaginemos que reescalamos entre cero y cien y entre cero y dos.

```{r}
students$Income.rescaled.100 <- rescale(students$Income, to = c(0,100))
students$Income.rescaled.2 <- rescale(students$Income, to = c(0,2))
```
\

En el caso de que necesitemos reescalar muchas variables, es posible usar funciones. Veamos:

```{r}
rescale.many <- function(dataframe, cols){
  names <- names(dataframe)
  for(col in cols){
    name <- paste(names[col], "rescaled", sep = ".")
    dataframe[name] <- rescale(dataframe[,col])
  }
  cat(paste("Hemos reescalado ", length(cols), "variable(s)"))
  dataframe
}
```
\
Veamos en qué consiste la función:

* Como siempre, la función tiene un nombre (_**rescale.many**_) y se genera utilizando la palabra reservada _**function**_. Según estamos definiendo la función, le pasaremos dos argumentos: un dataframe y el número de los columnas de interés (_cols_).
* En la variable _names_ vamos a guardar los nombres del dataframe original y luego vamos a hacer un bucle _**for**_ para buscar las columnas a reescalar.
* Por cada columna, entre las que indico que quiero reescalar, vamos a tomar su nombre y con la función _**paste**_ vamos a "unir" el nombre original de la columna con la palabra "rescaled" separadas por un punto. Este "nuevo nombre" lo guardaremos en la variable _name_.
* Luego, accedemos a todos los lugares donde el dataframe tome el nuevo nombre _name_ (que lo indicamos por dataframe[name]) y le asignamos la función _**rescale**_ de dicha variable y en particular de la columna en ese momento ([,col]).
* Finalmente, podemos sacar por consola un pequeño aviso usando la función _**cat**_ (muy similar a _**print**_)

\
Reescalamos a la vez dos columnas con la función anterior.

```{r}
students.2 <- rescale.many(students, c(1,4))
```
\
\
