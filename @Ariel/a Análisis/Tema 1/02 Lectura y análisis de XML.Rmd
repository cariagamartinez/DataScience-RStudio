---
title: "Lectura y análisis de archivos en formato XML"
output: html_notebook
---

### Lectura de archivos XML
\

Como primer paso instalaremos un paquete que no viene instalado en la base de R y que se llama XML. Como siempre, la sintaxis es: install.packages("XML") y cargamos:

```{r}
library(XML)
```
\

Vamos a guardar los datos leídos en una variable que llamaremos "url", de tal forma que no tengamos que invocar la ruta cada vez:

```{r}
url <- "/Users/macbookariel/Library/Mobile Documents/com~apple~CloudDocs/@ARIEL/AADD/DataScience/DataScience-con-RStudio/@Ariel/b Datos/tema1/cd_catalog.xml"
```

Como podemos ver, se ha guardado en una variable indistinta: la variable "url" que aparece en la pestaña _**Global Environment**_ no nos da ninguna información.

Ahora vamos a generar un "apuntador" que pre-leerá el XML utilizando la función _**xmlParse**_, del paquete XML. Llamaremos a este apuntador _"xmldoc"_.

El XML es un documento ordenado en nodos, así que para leer su contenido necesitamos obtener el nodo raíz y desde ahí, leerlo. Ese nodo raiz lo buscaremos con la función _**xmlRoot**_, desde el "apuntador". Aquí se recorrerá el XML desde la raíz (_root node_) e irá leyendo el contenido

```{r}
xmldoc <- xmlParse (url)
rootnode <- xmlRoot(xmldoc)
```

Si ejecutamos la sentencia _**rootnode**_, seguida del número del nodo entre corchetes, podríamos ver el contenido de cada nodo (así, _**rootnode[2]**_, nos daría el segundo nodo).

Pero esto no es muy útil, así que vamos a crear un csv para tener todos los datos en este formato.

Para ello, vamos a guardar los datos en una variable (_cds_data_) y usaremos una función del paquete XML (_**xmlSApply**_). 

```{r}
cds_data <- xmlSApply(rootnode, function(x) xmlSApply(x, xmlValue))
```

La función _**xmlSApply**_ tiene dos argumentos: el nodo raiz del que partimos, y la función _**xmlSApply**_ con su argumento _**xmlValue**_, para obtener todos los valores de cada $x$.

Tras ejecutar la sentencia anterior tendremos que trasponer el dataframe generado. Para trasponerlo usaremos la función _t_. Podemos indicar si cada fila tiene nombre con el valor _**row.names**_

```{r}
cds.catalog <- data.frame(t(cds_data), row.names = NULL)
```


### ¿Cómo funciona esto?
\

La función _**xmlParse**_, crea un fichero de tipo _XMLInternalDocument_, no trabajable en R. Al hacer _**xmlRoot**_, se lee toda la estructura. Luego con la función _**xmlSApply**_, vamos recorriendo cada nodo y con el argumento _**xmlValue**_, se extrae cada valor. El resultado es una matriz de datos, pero no es ningún "tipo" de dato. Por eso creamos un "dataframe", que se guarda en cds.catalog.

> Buscar información sobre:

> - _xpathSApply()_
> - _getNodeSet_
\

## Leyendo un HTML.

Un documento html es, en cierta forma, también una variante de XML. Por ello, vamos a leer un documento html que contiene tablas, de una forma "automatizada". 
En primer lugar guardaremos el documento en una variable y luego leeremos todas las tablas interiores con la función _**read.HTMLtable**_.

```{r}
  population_url <- "/Users/macbookariel/Library/Mobile Documents/com~apple~CloudDocs/@ARIEL/AADD/DataScience/DataScience-con-RStudio/@Ariel/b Datos/tema1/WorldPopulation-wiki.htm"
tables <- readHTMLTable(population_url)
```

Como vemos en _**Global Environment**_ se ha creado un dataframe llamado _tables_ que es una lista de 28 tablas. Sin embargo, son listas anidadas así que la sintaxis de acceso es doble corchete. Así, guardamos en una variable alguna tabla de interés. Por ejemplo, vamos a acceder a la tabla 6 (recordando que es una lista de listas)

```{r}
most_populated <- tables [[6]]
```


Si supiéramos exactamente la posición de la tabla, podríamos utilizar el argumento _**which**_ que indica exactamente el número de tabla al que se accedería.

```{r}
custom_table <- readHTMLTable(population_url, which = 10)
```
\

En la sentencia anterior accede a la tabla número 10. Este acceso es muy importante ya que a veces cargar en memoria todas la tablas para trabajar con una sola puede ser un problema o llevar mucho tiempo.
\
\

**RECORDEMOS QUE PODEMOS USAR LA FUNCIÓN read.HTMLTable CON PÁGINAS WEBS** 

**Ejemplo**:

* library(xml) #Cargamos la librería.
\
* datos = readHTMLTable("<<pon aquí tu URL>>") #Cargamos la tabla que esté en la url en la variable que se llama _datos_.